Task 1 
	Pentru Task1 avand un fisier binar am decis ca cea mai buna incercare de a
    descoperi adresa functiei vulnerabile este de a folosi Ghidra . Am creat un fisier nou Task1 in care am importat binarul . Dupa ce executabilul a fost analizat , Hidra mi-a furnizat o interpretare care include codul dezasamblat al programului . In ac timp Ghidra a detectat si anumite functii pe care le putem gasi in Symbol Tree . Astfel dam dublu click pe main si vom avea functia decompilata unde vom vedea 6 functii cu de tipul FUN_ADRESS.Astfel am consultat prima functie in care totul parea constuit corect , iar apoi am trecut la cea de-a doua unde am observat ca vectorul care este trimis ca parametru functiei read este de dimensiune 229 pe cand functiei read i se ofera 0xfd care inseamna 253 (253 > 229). Functia vulnerabila se gaseste la 080492f8 .
Task 2
	Pentru spargerea binarului am folosit atat ghidra , dar ca sa ma asigur si comanda objdump -M intel -d nice | less , cu ajutorul acestei comenzi am vazut ca la adresa 08049386 se afla mainul . Am cautat functia care se apeleaza in prima instanta , cea care se afla la adresa 
	80492de . Astfel in acest moment ma duc la aceasata adresa unde observ ca se aloca x83 pentru 
	citire si se pune pe stiva x83 adica se vor citi 131 de caractere . Ma intorc in main unde
	observa ca urmaroarea functie apelata este cea cu probleme si anume 080492f8 . Ma mut in 
	aceasta functie unde descopar ca se pune pe stiva xfd care inseamna in 253 pentru a se realiza citirea. Astfel daca realizam adunarea vom avea 131+253 = 384 dar stim ca in payload trebuie sa adaugam si adresa de print_flag care este 08049291 astfel trebuie sa luam in considerare si "memoria" (4 bytes) pe care o ocupa aceasta adresa astfel facem 384 -4 = 380 . In acelasi timp am observat faptul ca pe stiva se acolca xe5 (229 de caractere care pot fi scrise) si observam ca se realizeaza o mutare in eax de la [eb+0x14] (x14 = 29) astfel intelegem ca adresa print_flagului trebuie sa inceapa la 229+20 = 249 .Astdel am incercat comanda 
	python -c 'print "A"*131 + "A"*249  + "\x91\x92\x04\x08" ' > nice_payload  cu ajutorul careia am generat payloadul ,iar apoi ./nice < nice_payload cu ajutorul careia am obtinuit flagul . 
	NICE_FLAG{b7d7511a78248cc1c22501079adc6189}

Task3
	Pentru acest task a fost nevoie de multa rabdare , primele arhive pe care le-am descarcau pareau ca au un program care ruleaza la nesfarsit , asa ca am luat o noua arhiva . Initial la fel ca la taskurile anterioare am decis sa folosesc comanda objdump -M intel -d naughty | less .Astfel am inceput cu functia main in care m-am uitat pentru a vedea catre care functii se face call-ul . Astfel prima funtie este cea de la adresa 80492de unde putem observa ca se aloca 0x298 adica (664 de caractere care pot fi scrie) , dar observam ca la adresa 264 (664 - x1a0 (416)) se observa ca se pune 0x80492c8 care are trimiteri la apelul functiei resposabil cu puts ,dar noi vom supreascire acea adresa cu adresa print_flag adica 08049291 . Apoi este necesar datorita compararii sa mai adaugam in payload caractere astfel incat sa avem la adresa ebp-0x126 ( 664 - 294 = 370 ), adresa 0x60f92a44 astfel vedem cate caractere mai avem nevoie (370 - 248 - 4 = 118).
	. Astdel am incercat comanda
	python -c 'print "A"*248 + "\x91\x92\x04\x08" + "A"* 118 +"\x44\x2a\xf9\x60" ' > payload_naughty cu ajutorul careia am generat payloadul ,iar apoi ./naughty < naughty_payload  cu ajutorul careia am obtinut flagul.
	NAUGHTY_FLAG{9608c82c05224bca1256f02978487ab1}
